// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'
// Upgrade NOTE: replaced '_World2Object' with 'unity_WorldToObject'

Shader "ShaderDev/11NormalMap" 
{
    Properties 
    {
        _Color ("Main Color", Color) = (1,1,1,1)
        _MainTex("Main Texture", 2D) = "white" {}
        _NormalMap("Normal Map", 2D) = "bump" {}
    }

    SubShader
    {
        Tags 
        { 
            "Queue" = "Transparent" 
            "IgnoreProjector" = "True" 
            "RenderType" = "Transparent"
        }

        Pass
        {
            Blend SrcAlpha OneMinusSrcAlpha

            CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag

                uniform half4 _Color;
                uniform sampler2D _MainTex;
                uniform float4 _MainTex_ST; //variable generated by unity to tile and offset texture

                uniform sampler2D _NormalMap;
                uniform float4 _NormalMap_ST;

                struct vertexInput
                {
                    float4 vertex : POSITION;
                    float4 normal : NORMAL;
                    float4 tangent : TANGENT;
                    float4 texcoord : TEXCOORD0;
                };

                struct vertexOutput
                {
                    float4 pos : SV_POSITION;
                    float4 texcoord : TEXCOORD0;
                    
                    float4 normalWorld : TEXCOORD1; //MSDN Semantics does not have an attribute for normal or tangent so we place it in an element of the same type float4
                    float4 tangentWorld : TEXCOORD2;
                    float3 binormalWorld : TEXCOORD3;
                    float4 normalTexCoord : TEXCOORD4;
                };

                float3 normalFromColor(float4 colorVal) {
                    #if defined(UNITY_NO_DXT5nm) // If there is no DXT comnpression return this result
                        return colorVal.xyz * 2 - 1;
                    #else
                        //R => A
                        //G
                        //B => ignored
                        float3 normalVal;
                        normalVal = float3( colorVal.a * 2.0 - 1.0,
                                            colorVal.g * 2.0 - 1.0,
                                            0.0);
                        normalVal.z = sqrt(1.0 - dot(normalVal, normalVal)); //inspect lecture 29 for explanation of equation
                        return normalVal;
                    #endif
                }

                vertexOutput vert(vertexInput v) 
                {
                    vertexOutput o;
                    UNITY_INITIALIZE_OUTPUT(vertexOutput, o); //necessary for HLSL compilers
                    //o.pos = mul(UNITY_MATRIX_MVP, v.vertex); //this method is obsolete and couls not support all graph API's
                    o.pos = UnityObjectToClipPos(v.vertex);
                    o.texcoord.xy = (v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw); //x and y coordinates are for tilling. z and w coordinates are for offseting
                    o.normalTexCoord.xy = (v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw);

                    // World space T, B, N values
                    o.normalWorld = normalize(mul(v.normal, unity_WorldToObject));
                    o.tangentWorld = normalize(mul(unity_ObjectToWorld, v.tangent));
                    o.binormalWorld = normalize(cross(o.normalWorld, o.tangentWorld) * v.tangent.w);

                    return o;
                }

                half4 frag(vertexOutput i) : COLOR 
                {
                    //Color at Pixel which we read from Tangent space normal map
                    float4 colorAtPixel = tex2D(_MainTex, i.normalTexCoord);

                    //Normal value converted from Color value
                    float3 normalAtPixel = normalFromColor(colorAtPixel);

                    //Compose TBN matrix
                    float3x3 TBNWorld = float3x3(i.tangentWorld.xyz, i.binormalWorld.xyz, i.normalWorld.xyz);
                    float3 worldNormalAtPixel = normalize(mul(normalAtPixel, TBNWorld));

                    return tex2D(_MainTex, i.texcoord) * _Color;
                }

            ENDCG
        }
    }

    FallBack "Diffuse"
}