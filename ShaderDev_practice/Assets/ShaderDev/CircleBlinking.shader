Shader "ShaderDev/08CircleBlinking"  {

    Properties {
        _Color ("Main Color", Color) = (1,1,1,1)
        _MainTex ("Main Texture", 2D) = "white" {}
        _Center ("Center, only first 2 coord", Vector) = (0.5,0.5,0,0)
        _Radius ("Radius", Float) = 0.5
        _Feather ("Feather", Range(0.001, 0.5)) = 0.2
        _Speed ("Speed", Float) = 1.0
        _Bloom ("Bloom Strength", Float) = 1.0
    }

    SubShader {
        Tags { 
            "Queue" = "Transparent" 
            "IgnoreProjector" = "True" 
            "RenderType" = "Transparent"
        }

        Pass {
            Blend SrcAlpha OneMinusSrcAlpha

            CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag

                uniform half4 _Color;
                uniform sampler2D _MainTex;
                uniform float4 _MainTex_ST; //variable generated by unity to tile and offset texture
                uniform float4 _Center;
                uniform float _Radius;
                uniform float _Feather;
                uniform float _Speed;
                uniform float _Bloom;

                struct vertexInput {
                    float4 vertex : POSITION;
                    float4 texcoord : TEXCOORD0;
                };

                struct vertexOutput {
                    float4 pos : SV_POSITION;
                    float4 texcoord : TEXCOORD0;
                };

                vertexOutput vert(vertexInput v) {
                    vertexOutput o;
                    UNITY_INITIALIZE_OUTPUT(vertexOutput, o); //necessary for HLSL compilers
                    //o.pos = mul(UNITY_MATRIX_MVP, v.vertex); //this method is obsolete and couls not support all graph API's
                    o.pos = UnityObjectToClipPos(v.vertex);
                    o.texcoord.xy = (v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw); //x and y coordinates are for tilling. z and w coordinates are for offseting
                    return o;
                }

                float drawLine(float2 uv, float2 start, float2 end) {
                    if(uv.x > start.x && uv.x < end.x || uv.y > start.y && uv.y < end.y) {
                        return 1;
                    }
                    return 0;
                }

                float drawCircle(float2 uv, float2 center, float radius) {
                    float circle = pow((uv.y - center.y), 2) + pow((uv.x - center.x), 2);
                    float radiusSq = pow(radius, 2);

                    //could be replaced by 
                    //pos = (uv - center);
                    //distance = length(pos); //length gives the length of a vector
                    //if(distance < radius) {
                    
                    if(circle < radiusSq) { //can be replaced also by: distance(center, UVs) < radius
                        return 1;
                    }
                    return 0;
                }

                float drawCircleFade(float2 uv, float2 center, float radius, float feather) {
                    float circle = pow((uv.y - center.y), 2) + pow((uv.x - center.x), 2);
                    float radiusSq = pow(radius, 2);

                    //could be replaced by 
                    //pos = (uv - center);
                    //distance = length(pos); //length gives the length of a vector
                    //if(distance < radius) {
                    
                    if(circle < radiusSq) { //can be replaced also by: distance(center, UVs) < radius
                        return smoothstep(radiusSq, radiusSq - feather, circle);
                    }
                    return 0;
                }

                float drawCircleAnimate(float2 uv, float2 center, float radius, float feather) {
                    float circle = pow((uv.y - center.y), 2) + pow((uv.x - center.x), 2);
                    float radiusSq = pow(radius, 2);
                    
                    if(circle < radiusSq) {
                        float fadeVal = saturate(sin(_Time.y * _Speed)) * _Bloom;
                        return smoothstep(radiusSq, radiusSq - feather, circle) * fadeVal;
                    }
                    return 0;
                }

                half4 frag(vertexOutput i) : COLOR {
                    float4 col = tex2D(_MainTex, i.texcoord) * _Color;
                    col.a = drawCircleAnimate(i.texcoord, _Center.xy, _Radius, _Feather);
                    return col;
                }
            ENDCG
        }
    }

    FallBack "Diffuse"
}