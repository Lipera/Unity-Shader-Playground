/*  Original code[1] Copyright (c) 2015 jistyles[2]
    Released as "public domain, no restrictions, no requirements, no support"
    Modified code[3] Copyright (c) 2018 Shane Celis[4]
    Licensed under the MIT License[5]

    This comment generated by code-cite[6].

    [1]: https://forum.unity.com/threads/sharing-is-caring-hiding-optional-material-parameters.349952/
    [2]: https://forum.unity.com/members/jistyles.458393/
    [3]: https://gitlab.com/snippets/1828392
    [4]: http://twitter.com/shanecelis
    [5]: https://opensource.org/licenses/MIT
    [6]: https://github.com/shanecelis/code-cite
*/
//$ cite -u https://forum.unity.com/threads/sharing-is-caring-hiding-optional-material-parameters.349952/ \
// -X jistyles -Y 2015 -Z https://forum.unity.com/members/jistyles.458393/ \
// -x shane -l mit -m -U https://gitlab.com/snippets/1828392

using UnityEngine;
using UnityEditor;

/**
   Hide or show properties in a material based on whether a given keyword is
   enabled or not.

   For instance, suppose we have a shader that has a toggle `RENDER_LINES` and
   there are properties that are irrelevant when it is disabled.

```
   [Toggle(RENDER_LINES)]
   _RenderLines ("Render Lines?", Float) = 0
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

   We can add the following attribute to hide _LineDistance if RENDER_LINES is
   enabled. It reads, "hide if RENDER_LINES is false."

```
   [HideIf(RENDER_LINES, false)]
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

   Or we can hide it if RENDER_LINES is disabled.  It reads, "hide if RENDER_LINES is true."

```
   [HideIf(RENDER_LINES, true)]
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

   If no "true" or "false" argument is provided, it will default to true, so the
   following will hide if RENDER_LINES is enabled.  It reads, "hide if RENDER_LINES is true."

```
   [HideIf(RENDER_LINES)]
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

  ShowIf
  ------

  The drawer `ShowIf` performs the same function but instead reads differently.

  [ShowIf(X, true)]

  ```
  [Toggle(RENDER_LINES)]
  _RenderLines ("Render Lines?", Float) = 0
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  We can add the following attribute to show _LineDistance if RENDER_LINES is
  enabled. It reads, "show if RENDER_LINES is false."

  ```
  [ShowIf(RENDER_LINES, false)]
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  Or we can show it if RENDER_LINES is disabled.  It reads, "show if RENDER_LINES is true."

  ```
  [ShowIf(RENDER_LINES, true)]
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  If no "true" or "false" argument is provided, it will default to true, so the
  following will show if RENDER_LINES is enabled.  It reads, "show if RENDER_LINES is true."

  ```
  [ShowIf(RENDER_LINES)]
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  Limitations
  -----------

  * Cannot work with other attributes, e.g., IntRange.

  See this [tweet thread](https://twitter.com/shanecelis/status/1098714764962877440) to see it in action.
*/
public class HideIfDrawer : MaterialPropertyDrawer {
  protected string[] argValue;
  protected bool? _enabled;
  bool bElementMatches;

  protected bool enabled {
    get => _enabled ?? true;
    set => _enabled = value;
  }

  //constructor permutations -- params doesn't seem to work for property drawer inputs :( -----------
  public HideIfDrawer(string name1) {
    argValue = new string[] { name1 };
  }

  public HideIfDrawer(string name1, string name2) {
    if (bool.TryParse(name2, out bool e)) {
      argValue = new string[] { name1 };
      enabled = e;
    } else {
      argValue = new string[] { name1, name2 };
    }
  }

  public HideIfDrawer(string name1, string name2, string name3) {
    if (bool.TryParse(name3, out bool e)) {
      argValue = new string[] { name1, name2 };
      enabled = e;
    } else {
      argValue = new string[] { name1, name2, name3 };
    }
  }

  public HideIfDrawer(string name1, string name2, string name3, string name4) {
    if (bool.TryParse(name4, out bool e)) {
      argValue = new string[] { name1, name2, name3 };
      enabled = e;
    } else {
      argValue = new string[] { name1, name2, name3, name4 };
    }
  }

  //-------------------------------------------------------------------------------------------------

  public override void OnGUI (Rect position, MaterialProperty prop, string label, MaterialEditor editor) {
    bElementMatches = false;
    for(int i=0; i<editor.targets.Length; i++) {
      //material object that we're targetting...
      Material mat = editor.targets[i] as Material;
      if(mat != null) {
        //check for the dependencies:
        for(int j=0; j<argValue.Length; j++)
          bElementMatches |= (mat.IsKeywordEnabled(argValue[j]) == enabled);
      }
    }

    if(ShowElement(bElementMatches))
      editor.DefaultShaderProperty(prop, label);
  }

  protected virtual bool ShowElement(bool matched) => ! matched;

  //We need to override the height so it's not adding any extra (unfortunately
  //texture drawers will still add an extra bit of padding regardless):
  public override float GetPropertyHeight (MaterialProperty prop, string label, MaterialEditor editor) {
    //@TODO: manually standardise element compaction
    // float height = base.GetPropertyHeight (prop, label, editor);
    // return ShowElement(bElementMatches) ? height - 16f : 0f;

    return 0f;
  }

}

public class ShowIfDrawer : HideIfDrawer {

  public ShowIfDrawer(string name1) : base(name1) {
    this.enabled = true;
  }
  public ShowIfDrawer(string name1, string name2) : base(name1, name2) {
    this.enabled = true;
  }
  public ShowIfDrawer(string name1, string name2, string name3) : base(name1, name2, name3) {
    this.enabled = true;
  }
  public ShowIfDrawer(string name1, string name2, string name3, string name4) : base(name1, name2, name3, name4) {
    this.enabled = true;
  }

  // protected override bool enabled {
  //   get => _enabled ?? true;
  //   set => _enabled = value;
  // }

  protected override bool ShowElement(bool matched) => matched;
}
