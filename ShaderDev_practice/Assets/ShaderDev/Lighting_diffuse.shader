Shader "ShaderDev/13Lighting_diffuse" {
    Properties {
        _Color ("Main Color", Color) = (1,1,1,1)
        _MainTex("Main Texture", 2D) = "white" {}
        _NormalMap("Normal Map", 2D) = "bump" {}
        [KeywordEnum(Off,On)] _UseNormal("Use Normal Map?", Float) = 0
        _Diffuse("Diffuse %", Range(0,1)) = 1
        [KeywordEnum(Off, Vert, Frag)] _Lighting("Lighting Mode", Float) = 0
    }

    SubShader {
        Tags { 
            "Lighting Mode" = "ForwardBase"
            "Queue" = "Transparent" 
            "IgnoreProjector" = "True" 
            "RenderType" = "Transparent"
        }

        Pass {
            Blend SrcAlpha OneMinusSrcAlpha

            CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                //this line is used to compile several version of this shader based on the enums passed in the properties
                #pragma shader_feature _USENORMAL_OFF _USENORMAL_ON
                #pragma shader_feature _LIGHTING_OFF _LIGHTING_VERT _LIGHTING_FRAG
                #include "CVGLighting.cginc"

                uniform half4 _Color;
                uniform sampler2D _MainTex;
                uniform float4 _MainTex_ST; //variable generated by unity to tile and offset texture

                uniform sampler2D _NormalMap;
                uniform float4 _NormalMap_ST;

                uniform float _Diffuse;
                uniform float4 _LightColor0;

                struct vertexInput {
                    float4 vertex : POSITION;
                    float4 normal : NORMAL;
                    float4 texcoord : TEXCOORD0;
                    #if _USENORMAL_ON
                        float4 tangent : TANGENT;
                    #endif
                };

                struct vertexOutput {
                    float4 pos : SV_POSITION;
                    float4 texcoord : TEXCOORD0;
                    float4 normalWorld : TEXCOORD1; //MSDN Semantics does not have an attribute for normal or tangent so we place it in an element of the same type float4
                    #if _USENORMAL_ON
                        float4 tangentWorld : TEXCOORD2;
                        float3 binormalWorld : TEXCOORD3;
                        float4 normalTexCoord : TEXCOORD4;
                    #endif
                    #if _LIGHTING_VERT
                        float4 surfaceColor : COLOR0;
                    #endif
                };

                float3 DiffuseLambert(float3 normalDir, float3 lightDir, float3 lightColor, float diffuseFactor, float attenuation) {
                    return lightColor * diffuseFactor * attenuation * max(0, dot(normalDir, lightDir));
                }

                vertexOutput vert(vertexInput v) {
                    vertexOutput o;
                    UNITY_INITIALIZE_OUTPUT(vertexOutput, o); //necessary for HLSL compilers
                    //o.pos = mul(UNITY_MATRIX_MVP, v.vertex); //this method is obsolete and couls not support all graph API's
                    o.pos = UnityObjectToClipPos(v.vertex);
                    o.texcoord.xy = (v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw); //x and y coordinates are for tilling. z and w coordinates are for offseting
                    o.normalWorld = normalize(mul(v.normal, unity_WorldToObject));

                    #if _USENORMAL_ON
                        // World space T, B, N values
                        o.normalTexCoord.xy = (v.texcoord.xy * _NormalMap_ST.xy + _NormalMap_ST.zw);
                        o.tangentWorld = normalize(mul(v.tangent, unity_ObjectToWorld));
                        o.binormalWorld = normalize(cross(o.normalWorld, o.tangentWorld) * v.tangent.w);
                    #endif
                    #if _LIGHTING_VERT
                        float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);
                        float3 lightColor = _LightColor0.xyz;
                        float attenuation = 1;
                        o.surfaceColor = float4(DiffuseLambert(o.normalWorld, lightDir, lightColor, _Diffuse, attenuation), 1);
                    #endif
                    return o;
                }

                half4 frag(vertexOutput i) : COLOR {
                    #if _USENORMAL_ON
                        float3 worldNormalAtPixel = WorldNormalFromNormalMap(_NormalMap, i.normalTexCoord.xy, i.tangentWorld.xyz, i.binormalWorld.xyz, i.normalWorld.xyz);
                    #else
                        float3 worldNormalAtPixel = i.normalWorld.xyz;
                    #endif

                    #if _LIGHTING_FRAG
                        float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);
                        float3 lightColor = _LightColor0.xyz;
                        float attenuation = 1;
                        return float4(DiffuseLambert(worldNormalAtPixel, lightDir, lightColor, _Diffuse, attenuation), 1);
                    #elif _LIGHTING_VERT
                        return float4(i.surfaceColor, 1);
                    #else
                        return float4(worldNormalAtPixel, 1);
                    #endif
                }

            ENDCG
        }
    }

    FallBack "Diffuse"
}